[TOC]



## 存储过程

实例表user

```
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `email` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `sex` int(255) DEFAULT NULL,
  `schoolName` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4;
```

```
-- 创建存储过程
delimiter $$
create procedure `yeecode`(in `ageMinLimit` int,in `ageMaxLimit` int,out `count` int,out `maxAge` int)
begin
select count(*),max(age) into count,maxage from user where age>=ageMinLimit and age<=ageMaxLimit;
end$$
```

------

## MySQL基础

### 架构

MySQL是典型的客户端/服务器架构

**启动MySQL服务器的脚本**

脚本位于安装目录的bin目录下.

mysqld

mysqld_safe,提供监控和服务错误时重启.

mysql.server 调用mysqld_safe

mysqld_multi 启动多个mysql服务实例.

**服务器处理客户端请求**

连接管理-缓存/解析优化/-存储引擎

### 启动选项和配置文件

#### 查询启动选项

`mysql --help`

`mysqld_safe --verbose --help`

#### 配置文件启动选项

不同程序可以对应多个组启动选项,如mysqld可以对应[mysqld] [server]组配置

### 系统变量

查看系统变量和值. `show variables [like 匹配模式]`

修改系统变量 `set [GLOBAL|SESSION] 系统变量名=值`

### 字符集和比较规则

查看mysql中支持的比较规则

`show collation [like 匹配模式]`

#### 客户端和服务器在通信过程中使用的字符集

从客户端发送到服务器返回相应中间经历多次字符转换.

**客户端发送请求**

客户端以操作系统使用的字符集发送请求

**服务器接受请求**

服务器把字节序列看成使用`character_set_client` 代表的字符集.

**服务器处理请求**

在处理请求时转变为`character_set_connection`对应的字符集

**服务器生成响应**

`character_set_results`对应的字符集,

**客户端收到响应**

同样使用操作系统的字符集.

### InnoDB行格式

**compact行格式**

1. 记录变长字段列表
2. 记录null值列表
3. 记录头信息:下条记录指针,记录类型等.
4. 真实数据

**dunamic行格式**

对于溢出页,只用20字节指向溢出页地址.

## InnoDB数据页

1. UserRecord存储用户记录,数据在页中按照主键大小排列成单项链表
2. Pige Dicectory存放着槽信息,是每个组内最大记录地址偏移量.
3. 使用二分查找在单个数据页内搜索.

## B+树索引

1.目录页数据结构,包含两个部分用户数据页最小键值,和页号.

**聚簇索引**

1.数据按照主键大小排列

2.B+树叶子节点数据携带所有用户数据.

**二级索引**

与聚簇索引类型,按照索引键值排列,目录项使用键值+主键+页号搭配,叶子节点存储键值+主键.

其他问题,关于B+树,如何页分裂,如何保持平衡.

**作用**

1. 索引可以充当边界条件,确定B+树上扫描区间.

​	如`id>=2 and id<=1000` 可以把查询范围确定在[2,100]之间,避免全	表扫描.

2. 索引列是天然有序的,可以用来排序. 

## InnoDB表空间

### 独立表空间

#### 独立表空间 

表空间是存放索引页的数据池,在文件系统中存在`.ibd` 实际文件.

**区的概念:**

​	区是物理位置上连续的64页,每个区1MB(=64*16KB).区存在的作用给页分配连续的物理空间,减少磁盘IO.

**段的概念:**

​	将B+树叶子节点和非叶子节点区分,可以提升查询时扫描节点的速度.因此有了段的概念:一个叶子节点段,一个非叶子节点段.

**碎片区的概念:**

​	碎片区用于表数据量比较小的时候,存储数据.刚开始向表中插入数据的时候,从碎片区以单个页面为单位分配,超过一定页面.则以区为单位分配空间.目的在于节省直接申请叶子节点段,非叶子节点段产生的2MB空间.

#### 链表管理区

区的4种状态                                                                                                                                                   

* FREE: 空闲的区
* FREE_FRAG 有剩余空闲页面的碎片区
* FULL_FRAG 没有剩余空闲页面的碎片区
* FSEG 附属于某个段的区

使用XDES管理区

​	在每组分组(256区一组)前两个页面中,有个XDES页,用来登记本组256区的属性.XDES Entry属性:

* Segment ID:段编号ID.
* List Node: 这个结构里面有Prve Next 将XDES Entry结构串成一个链表.
* State: 区的4中状态.
* Page State BitMap:用于表示页是否空闲.

**链表管理区**:

1. 管理碎片区:通过FREE,FREE_FRAG,FULL_FRAG3个链表.头节点尾节点在表空间第一个页面存储.
2. 管理段区,FREE,NOT_FULL,FULL3个链表.链表头节点尾节点在段中存储

这些链表目的在于,将碎片区和段中区按照状态链接成串,方便查找哪些区有空间可以使用.

#### 段是零散页面和完整区集合

完整区集合体现在,每个区都有个Seament ID,零散页面体现在段对应的INODE Entry结构中存储零散页面的页号.INODE Entry在表空间中存储.

段的作用总结:1段是物理上连续的存储空间.2段存储了空闲区链表的头节点.

### 系统表空间

InnoDB提供了一系列描述表信息的信息,称为元数据.比如,有多少表,表中的列,索引,表空间地址.体现在`information_schema` 数据库中.

## 高性能查询

### 选择合适的数据类型

1. **使用足够用的数据类型**.较大的列占用更大的内存,对与使用内存临时表和排序
2. **有时可以使用数据类型代替字符串类型**.在排序场景中速度更快.
3. **使用主键自增长**.B+树上索引页可以向右扩展,避免频繁对已有的索引页分裂.
4. **尽量避免使用null值**.
   * 提升可维护性.
   * 在 `not in !=`等查询条件下返回空结果,不可预料性比较多
   * 数据行中使用单独的空间判断是否有null列.

### 创建高性能索引

#### 索引的优点

* 使用索引可以在B+树上确定扫描边界,减少扫描区间.
* 索引可以避免排序的临时表
* 索引可以使随机IO变为顺序IO.

#### 高性能索引策略

1. 选择合适长度的长度的前缀索引.
2. 创建合适的联合索引.当优化器选择使用索引合并,说明这些索引本来就有可能应该,需要考虑创建多列索引.
3. 使用覆盖索引.可以节省回表成本.
4. 使用索引做排序和分组.
   * 使用联合索引是,order by 后面的列顺序应该和联合索引顺序一致.
   * 不要混用ASC DESC,要么都是升序,要么都是降序.
   * 没有索引使用分组,就要创建临时表.
5. 让索引以列名形式单独出现.不要有函数或算数运算.

### 查询优化

#### 业务优化

1. 是否请求了不需要的数据.如分页没有使用limit,总是`selelct * `等

2. 使用复杂查询还是多个简单查询.

   * 有时可以将大的查询分成多个小查询.如定期清除大量数据.

   * 分解联合查询.可以在应用层使用缓存,可以减少锁竞争,in()查询可以顺序扫描比链表随机IO效果好点等.

#### Mysql查询优化

见下一节

## MysqlSQL查询优化

### 索引合并

把使用多个索引来完成一次查询的执行方法称为index merge(索引合并).

**Intersection 索引合并**:取索引交集进行回表操作

**Union索引合并**:二级索引记录按照主键排序取并集按照主键排序

**Sort-Union**:先把扫描的记录进行主键排序,在进行Union索引合并.

### 连接

#### **概念**

内连接:驱动表在被驱动表中找不到匹配记录,则在结果集不显示该记录.

外连接:驱动表在被驱动表无法匹配到记录(特指on子句无法匹配),也显示驱动表中无法匹配的记录.

#### **连接过程**

1. 选取驱动表,对驱动表进行单表查询
2. 对驱动表中的每一条记录,都在被驱动表中查询.

​	说明:在被驱动表中加入索引可以提升查询速度,使用Join Buffer缓存驱动表记录.

#### 原理

基于嵌套循环连接,驱动表只会访问以便,而被驱动表要根据驱动表中查询结果访问多次.

### 连接成本计算

#### 执行计划生成过程

1. 根据搜索条件找出所有可能使用的索引列.
2. 计算全表扫描代价.
   * IO成本=页面数量*1.0+1.1
   * CPU成本=rows*0.2+1.0
   * Rows Data_length信息来源`show table status`统计,
   * 页面成本使用Data_length计算
3. 使用二级索引代价
   * IO成本=扫描区间数量
   * CPU成本=B+树扫描记录* 0.2+回表记录*0.2
   * 这里需要注意的问题是,二级索引扫描数据内的记录数量是从最左记录开始向右读取10个页面的平均数量估算出来的.(index dive)
4. 比较不同执行方案,选取成本最低的方案

#### In子句统计扫描数量

1. in查询小于200时,使用上面说的查询数量估算.
2. 大于200时,扫描数量=in对应的单点扫描区间*重复次数.重复次数=rows/不重复值数量.(`show index from table 获得`)

### 多表连接分析

#### 成本

多表连接成本=驱动表单表成本+扇出量*被驱动表连接成本,对于内连接不同驱动表所产生的连接成本是不一样的.

### 查询优化

#### 条件简化

如,Havaing与Where合并.没有没用的判断条件等.

#### 外连接消除                                                                                                                                      

被驱动表中的列为null时,外连接可以转换为内连接.转换完之后,优化器可以切换驱动表重新评估成本.

#### 子查询优化

##### in子查询优化

当in子查询中,子查询结果过多,作为in参数过多,可能内存都放不下.

方案:

**半连接**

对于形如`select ... from  outer_table where exprx in (select ... from inner_table ...) and ...` 可以转成半连接查询.

* 子查询结果写入临时表(一般在内存中),这个称为物化.
* 将子查询转换成半连接,半连接相当于给结果集去重,因为当被动表有多条记录符合on条件时,结果集会出现重复记录.半连接的意思就是结果集中值保留驱动表的记录.
* 怎么消除半连接结果集重复记录.
  * 如果驱动表中使用唯一索引,那么不用消除了.
  * 给结果集建立临时表通过id去重.

## Explain--查询优化

### 执行计划输出列解释

explain 列如下

| id   | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
| ---- | ----------- | ----- | ---------- | ---- | ------------- | ---- | ------- | ---- | ---- | -------- | ----- |

#### id

1. 查询语句中没出现一个select 关键字,mysql就会为它分配一个唯一的id.
2. 对于连表查询,会生成id相同的两条记录(如果只有两张表).
3. 同时查询优化器可能对子查询语句进行重写,转换为连接查询,那么id也相同.

4. 对于union查询,会产生id为null的记录,产生临时表

#### select_type

描述查询扮演的角色.

1. simple:不包含uniont或者子查询的就是simple,常见的单表查询.
2. pirmary:对于union/union all,或者子查询来说,最左边的子查询的select_type就是primary.

### 实战,使用慢查询日志和explain优化sql

## Buffer Pool

读取页数据时的内存缓存称为buffer pool

mysql通过链表管理buffer pool

**free链表**

用来管理空闲的缓冲页控制块

**flush链表**

管理脏页缓冲页

**LRU链表**

按照最少使用原则淘汰缓冲页,首次加载放到old区,后续访问放在young区.



## redo日志

### 什么是redo日志

在修改buffer pool时,将对页的新增修改等操作记录在日志中.即为redo日志.

特点:

	1. 占用空间小
	1. 顺序写入磁盘,没执行一条sql,产生若干条redo日志,会顺序写入磁盘.

### 格式

type:

MLOG_8TYTE:表示在页面的某偏移量处写入8个字节的redo日志.

比如:当某个驶入想包含row_id列插入一条记录,并且该记录row_id为256整数倍时,就会向Buffer Pool中系统表空间页号7相应的偏移量写入8个字节的row_id.

插入一行数据:

MLOG_COM_REC_INSERT:表示插入一条类似COMPACT行格式的日志类型.

**redo日志指明了用数据(data)对哪个表空间(space ID)的哪个页(page number)进行修改进行什么类型(type)的修改.**

### Mini-Transation

* 以组写入redo日志,比如说

  1. 向B+树聚簇索引中写入一条记录产生的redo日志是一组,不可分割.

  1. 向B+树二级索引插入的一条记录产生的redo日志是一组,不可分割.

* 为什么要分组?

​	因为插入操作可能会让B+树叶子节点产生页分裂,这时候这些日志天然就是一组,要么都成功要么都失败,否则执行redo日志会让B+会变得混乱.

* 那么如何分组

  解析到MLOG_MULTI_REC_END 类型的redo日志时,才认为解析到一组完整的日志.

* 什么是Mini-Transaction

  对页面(如数据也)的一次原子操作称为Mini-Transation,比如修改Max Row ID.一个MTR包含一组redo日志.

### 写入redo

* 如何写入redo日志.

  1. 向log buffer中按组顺序写入redo日志.

  2. log buffer中redo日志刷盘时机

     * 事务提交

     * 刷新脏页前,将脏页产生的redo日志刷新到磁盘.

     * 定时线程,大概一秒钟一次频次刷盘.

     * checkpoint时.

### redo日志文件

* 文件系统上的redo日志

  把redo log block镜像写入日志文件,所以redo日志文件也是有512字节的block组成.当文件前2048字节描述了redo文件的整体属性

  包括LOG_HEADER_START_LSN,checkpoint属性.

* LSN

  1. lsn:写入log buffer但没刷新到磁盘的redo日志量,8704+偏移量

  2. flushed_to_disk_lsn:表示刷新到磁盘的的日志量.

     **lsn与flushed_to_disk_lsn相同,表示所有redo日志写入到磁盘中.**

  3. flush链表中LSN,

### checkpoint

可以被覆盖的redo日志量有多少

作用:

1. 让系统从异常中恢复数据;
2. checkpoint后磁盘的redo日志文件即可覆盖,有效利用重复文件.

### 奔溃恢复

**确实恢复起点**

选取lsn>=checkpoint_lsn的redo日志开始恢复页面.

**确定恢复终点**

从checkpoint_lsn对应的日志文件组开始扫描,扫描当前block(一组)redo日志用了多少字节.

## undo日志

### delete操作对应的Undo日志

过程:

1. 将记录头中delete_flag设置为1,这个称为delete mark.

2. 在删除语句提交之后,mysql purge线程处理删除.

## 复制

复制解决的问题是然一台服务器数据与其他服务器保持同步.工作过程:

1. 源写日志到binlog中
2. 副本将日志复制到中继日志中.
3. 副本读取中级日志,重放到副本上.

### 复制拓扑

#### 双源主动-主动架构

两台服务器相互复制.

**问题**:当双方都发送写入流量的时候,可能会运行错误.解决方式,通过主键奇偶数散列选择将记录发送到某一台服务起.

#### 主动/被动模式

所有读取和写入都指向单个源服务器.





