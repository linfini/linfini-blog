[TOC]

这部分介绍内存管理和垃圾回收

### 1.Java内存区域与内存溢出异常

Java虚拟机的自动内存管理机制帮助我们自动分配和销毁内存.

#### 1.1运行时数据区域

![img](https://pic2.zhimg.com/80/v2-a1cf6bf507d167385752aa635d9134e5_720w.webp)



1. **程序计数器**: 可以看做字节码指令流的行号指示器,通过改变计数器的值来选取下一条指令.程序分支,循环跳转,异常处理都需要依赖程序计数器.程序计数器不会发生内存溢出`OutOfMemoryError`

2. **虚拟机栈:** 虚拟机栈描述Java方法执行的内存模型,每个方法执行的时候,虚拟机都会同步创建一个栈帧,用于局部变量,操作数栈,动态链接等信息.

   **StackOverflow **: 当栈帧大于-Xss设置的值,就会引发该异常,常见于死循环.

3. 本地方法栈:为native方法服务,同虚拟机栈.hotspot中,本地方法栈和虚拟机栈合二为一.

4. **Java堆:** 对象实例在堆上分配,Java在逻辑上认为内存空间连续,大对象则要求实际的连续空间.通过-Xmx -Xms参数设定堆大小.

5. **方法区:** Jdk8之前交永久代,Jdk8中使用元空间实现.这部分内存回收主要针对常量池回收.

   **运行时常量池**: 在类加载后把Class文件中的常量表 存放在运行时常量池.但是进入常量池不一定在解析阶段,有可能在运行阶段.参考类加载解析和动态分派的概念.

#### 1.2HotSpot中对象

HotSpot中对象分配,布局,和访问

**对象的创建**:

1. 当遇到new指令之后，首先会去到**静态常量池**中看看能否找到这个指令所对应的**符号引用**，然后会检查**符号引用**所对应的**类**是否被**加载——连接——初始化**，如果有的话就进行下一步，如果没有就要先进行类的加载。

2. 执行类加载

3. 为新生对象分配内存

   分配策略:

   * 指针碰撞:当有足够大内存空间时,将指针移动向空闲空间防线.并发分配内存的问题,采用CAS失败重试机制或采用本地线程缓冲区分配.
   * 空闲列表:内存碎片化严重时,就只能采用表记录可用的内存空间.

4. 设置初始值和对象头
   **虚拟机需要将分配到的内存空间中的数据类型都初始化为零值（不包括对象头）**，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值

   初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. 执行构造函数，即class文件中<init>（）方法

**对象的内存布局**

对象在对内存布局：对象头，实例数据，和对齐填充。

* **对象头**

1. 线程运行时数据，哈希码，GC分代年龄，锁状态标识，线程持有锁，偏向线程ID等。
2. Java类型指针，指向方法区元数据的指针,Java虚拟机用这个指针确实该对象是哪个类的实例

* **实例数据** :即对象字段内容.

**对象访问方式**

是由虚拟机实现的,主流有句柄和直接指针两种:

1. **句柄访问,**句柄中包含了对象实例数据与类型数据各自具体的地址信息.reference中可以存储稳定的句柄地址.
2. **直接指针访问**,引用reference中存储的直接就是对象地址,指向实例数据.访问速度快.

![img](https://img-blog.csdn.net/20180829135125817?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDA1OTQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![img](https://img-blog.csdn.net/20150710172441054?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



**虚拟机栈溢出**

hotsopt不支持栈动态扩展,因此除非创建线程申请内存的时候内存不足会抛出OOM一场,否则只会抛出`StackOverFlowError` 异常.

`-Xss` 参数配置栈内存

**方法区和运行时常量池溢出**

1. JDK6中循环调用String::intern()方法会产生OOM:PermGen space
2. JDK7中原本存放与永久代的字符串常量池被移到了Java堆中.载循环执行上述方法只会得到OOM:Java heap sapce

**本机直接内存溢出**

直接内存默认与Java堆最大值一直,也可以通过`-XX: MaxDirectMemorySize` 参数指定. 



------

### 2.垃圾收集器和内存分配策略

程序计数器,虚拟机栈,本地方法栈3块内存区域,是线程私有,线程结束时,内存自动回收.堆和方法区的内存分配和销毁是动态,以下介绍管理收集器如何管理这部分内存.

#### 2.1判断对象死亡

1. 引用计数法:对象被引用时,计数器+1,当引用失效时计数器-1.当计数器为0时,对象不能再被使用.这个算法比较经典,但是比较难以解决循环引用的问题,需要额外空间存储和频繁更新.

2. 可达性分析算法:主流虚拟机采用的算法.如果某个对象到GC Roots对象间没有任何引用链相连,则对象不能被使用.

   GC Roots是一组必须活跃的引用,可以是栈中引用,静态引用对象.常量池引用,`syschronized` 锁持有对象等.

**引用类型**

1. **强引用**:只要强引用关系还在,那就不是垃圾对象.垃圾收集器永远不会回收被引用的对象.使用new创建的引用关系.

2. **软引用**:用`java.lang.ref.SoftReference`实现，可以让对象豁免一些垃圾收集,说明是非必须的。当系统内存充足的时候，不会被回收；当系统内存不足的时候，会被回收。

   使用场景:一个应用需要读取大量的本地图片，如果每次读取都从硬盘读取会严重影响性能，如果一次性全部加载到内存，内存可能会溢出。

3. **弱引用**:弱引用需要用`java.lang.ref.WeakReference`实现，它比软引用的生存期更短，对于弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否够，都会回收该对象的占用内存,说明这个对象是多余的。

4. **虚引用**:虚引用要通过` java.lang.ref.PhantomReference`类来实现，虚引用不会决定对象的生命周期，如果一个对象只有虚引用，就相当于没有引用，在任何时候都可能会被垃圾回收器回收。它不能单独使用也不能访问对象，虚引用必须和引用队列联合使用。

#### 2.2垃圾回收算法

垃圾收集建立在分代假说之上:1.绝大多数对象都快速消亡;2.熬过越多次垃圾收集的对象就越难消亡.

根据对象年龄划分出不同的区域.年纪小的经常回收,年纪大的不怎么回收.基于这个理论,一般有新生代,老年代的划分.

**跨代引用假说**:跨代引用占少数.

在回收新生代对象的时候,需要在GC Roots之外,额外遍历老年代对象保证可达性分析准确.所以在新生代建立卡表,标记老年代哪块内存区域存在跨代引用,从而避免扫描整个老年代.

**标记-清除算法**:标记需要回收的对象,标记完成后统一回收被标记的对象.

缺点:

1. 执行效率随着对象数量增长而降低
2. 标记-清除完成之后会导致没有足够连续的空间

**标记-复制算法**:将可用内存划分为两块,当一块内容使用完了,就存活的对象复制到另一块,并将已经使用的内存空间清理掉.为了解决标记-清除算法效率低的问题.大部分虚拟机在新生代采用这种算法.

* **分配担保**:一般新生代划分为Eden和Surviror两块空间,Hotspot中默认比例是8:1.如果Minor GC之后存活的对象超出Survivor空间,则依赖其他区域(老年待)继续担保

**标记-整理算法**:在老年代采取的算法,因为老年代对象存活率较高,不适合标记-复制算法.在标记完成对象之后,对存活对象进行进行移动.

缺点:由于要移动程序需要停顿

由于标记-整理算法和标记-清除算法都存在缺点.产生了一种混合式的回收策略,大部分时间都用标记--清除算法回收,当内存碎片化过于严重时,采用标记-整理收集获取规整的内存空间.

#### 2.3 经典垃圾收集器

这部分主要介绍如何实践上面的内存回收算法.下图是hotspot中的垃圾收集器

`java -XX:+PrintCommandLineFlags -version ` 可以查看当前垃圾收集器

![](C:\Users\vayno\workspace\linfini-blog\docs\_posts\Java虚拟机\img\03.png)

##### 2.3.1 GMS收集器

特点:

1. GMS以最短回收时间为目标.并发收集,可以和用户线程一起工作.低停顿
2. 抢占部分线程,导致应用程序变慢
3. 由于用户线程和垃圾清理同时进行,GMS无法处理新产生的垃圾.
4. 另外就是标记-清除算法的缺点,产生内存碎片

##### 2.3.2 G1收集器

G1是JDK9中默认的垃圾收集器

特点:

1. G1的收集范围不是,新生代 老年代 或整个堆,而是回收集
2. 以减少停顿时间为目标
3. 将region作为最小回收单元,心神带老年代不再固定.
4. 缺点占用内存高点.

步骤:

1. 初始标记:仅标记GC Roots能直接关联大奥的对象.需要短暂停顿
2. 并发标记:对堆中对象进行可达性分析,递归扫描所有对象.可取用户线程并发执行.
3. 最终标记:暂停,处理并发阶段用户线程变动的对象.
4. 筛选回收:通过复制算法回收对象.

### 3.虚拟机监控和故障处理

#### 3.1基础故障处理工具

**jps:虚拟机线程状况工具**

![jps](C:/Users/vayno/workspace/linfini-blog/docs/_posts/Java虚拟机/img/jps.png)

**jstat:虚拟机统计信息监控工具**

![](C:/Users/vayno/workspace/linfini-blog/docs/_posts/Java虚拟机/img/jstat.png)

**jinfo:Java配置信息工具**

jps使用-v参数可以查看启动时显示指定参数,查询所有参数可以通过jinfo

**jmap:Java内存映射工具**

jmap(Memory Map for Java)命令用于生成heap dump文件.通过` -XX +HeapDumpOnOutOfMemmoryError` 参数也可以生成dump文件.

jmap还可以用来查询finalize执行队列,Java堆和方法去详细信息,空间使用率,当前收集器信息等

![](C:/Users/vayno/workspace/linfini-blog/docs/_posts/Java虚拟机/img/jmap.png)

**Jhat:虚拟机dump分析工具**

用于分析dump文件

**jstack:Java堆栈跟踪工具**

jstack(Stack Trace for Java)命令用于生成theaddump文件快照.

#### 3.2 JVM参数

**标准参数**

jvm标准参数,在jvm各个版本中基本不变.使用`java`输出所有标准参数 如-version等

使用`java -version` 输出版本信息.

```
C:\Users\Administrator>java -version
java version "1.8.0_51"
Java(TM) SE Runtime Environment (build 1.8.0_51-b16)
Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode)
```

**X参数**

非标准化参数,在jvm各个版本中会有一点小变化.使用`java -X` 获取所有X参数

-  -Xint：JVM以解释方式执行所有的字节码，会显著降低运行速度（interpreted） 
-  -Xcomp：JVM在第一次使用时就把所有字节码编译为本地代码（compiled） 
-  -Xmixed：混合模式**(默认)**，由jvm自己决定是否编译为本地代码，会将字节码中多次被调用的部分便以为本地代码以提高执行效率；被调用很少的方法会在解释模式下执行，减少编译和优化成本 

```
PS C:\Users\vayno\workspace> java -Xint -version
openjdk version "11.0.12" 2021-07-20
OpenJDK Runtime Environment Microsoft-25199 (build 11.0.12+7)
OpenJDK 64-Bit Server VM Microsoft-25199 (build 11.0.12+7, interpreted mode)
PS C:\Users\vayno\workspace> java -Xcomp -version
openjdk version "11.0.12" 2021-07-20
OpenJDK Runtime Environment Microsoft-25199 (build 11.0.12+7)
OpenJDK 64-Bit Server VM Microsoft-25199 (build 11.0.12+7, compiled mode)
```

****

**XX参数**

 非标准化参数，在jvm各个版本中变化较大，主要用于jvm调优和debug，也是**最常用**的参数
  使用`java -XX:+PrintFlagsFinal -version > flags1.txt`命令获取所有XX参数^③^，大约有700+参数

-  Boolean 类型
  格式：-XX:[+-]  表示启用或者禁用name属性
  举例：-XX:+UseConcMarkSweepGC  启用CMS垃圾收集器
  -XX:+UseG1GC	 启用G1垃圾收集器 
-  K-V 类型
  格式：-XX:[+-]=   表示name属性的值是value
  举例：-XX:InitialHeapSize=3116367872   初始化堆内存，常用`-Xms512m`表示，不要误认为是X参数  

常用:

```
-XX:MaxHeapSize=3116367872
   最大堆内存，常用-Xmx1024m
表示
-XX:ThreadStackSize=1024
    线程堆栈大小，常用-Xss128k
表示
-XX:MaxGCPauseMills=500
   表示GC的最大停顿时间是500ms
-XX:GCTimeRatio=19
```



#### 3.3 可视化故障处理工具

todo

#### 3.4 实战:定位并解决线上OOM问题

todo

#### 3.5分析死循环与死锁

CPU负载(load average)和使用率过高，很可能的原因就是死循环。

1.  首先可以使用top命令查看占用CPU最高的**进程信息**，获取进程pid 
2.  使用Linux命令`top -p [pid] -H`监控指定进程中所有**线程信息**，然后找到CPU占用率高的线程nid，`-p`参数表示指定 pid，`-H`参数显示线程的信息，包括线程 ID 和 CPU 占用率等
   （windows中可以process exlporer工具查看指定进程中所有**线程信息**）
   ![img](http://upload-images.jianshu.io/upload_images/3274507-c01c8ab3cd4d6c98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
   如图可以看到`8247(0x2037)`线程的CPU使用率达到了96.7%，此时我们就可以确认是这个线程的问题了。(4核心电脑，每个线程最大CPU使用率为100%，总使用率最大为400%) 
3.  使用`jstack [pid] > myStack.txt`命令打印指定java进程的所有线程堆栈信息 
4.  在`myStack.txt`文件中查看线程id为**nid**的堆栈信息（`myStack.txt`线程id是**16进制**，`top -p`命令线程id是**10进制**），找到导致CPU飙升的`线程[10进制 PID=8247，16进制 nid=0x2037]`堆栈信息了，然后分析问题，解决问题。![img](http://upload-images.jianshu.io/upload_images/3274507-91fdd30e873d91d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 



根据上图中`线程8247(0x2037)`的堆栈信息，我们猜测是`CpuController.loop()`方法导致的cpu负载过高，然后我们就可以分析代码，解决问题了。



1. 另外`jstack`命令还能自动**检测死锁**，如果存在死锁，在myStack.txt末尾会有一行`found 1 deadlock`，也会打印死锁线程的相关信息，根据这些信息就可以轻松定位到死锁代码，解决CPU负载过高的问题了。



![img](http://upload-images.jianshu.io/upload_images/3274507-50fd6f4c6d5a6d8d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



另外，相比`jstack`命令来检测死锁，我们还有更轻松的方式，使用JConsole工具来检测死锁。
![img](https://upload-images.jianshu.io/upload_images/3274507-82cce72ee424d906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)











​                                          

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

