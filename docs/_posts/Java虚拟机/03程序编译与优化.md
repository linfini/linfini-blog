[TOC]

### 1 前端编译器与优化

Java技术下的编译有可能指

1. 前端编译,即把*.java文件转换成为*.class文件的过程;
2. 也可能是指Java虚拟机的即使编译器(常称为JIT编译器),即运行期间把字节码转变为本地机器码的过程;
3. 还可能是指静态提前编译器(常称为AOT编译器).

#### 1.1 Javac编译器与语法糖

Java最常见语法糖包含泛型,变长参数,自动装箱拆箱等等.解语法糖在Javac编译过程最后的字节码生辰阶段出发.

##### 1.1.1 泛型

Java选择实现泛型的方式叫做"类型擦除式泛型",也就是泛型只在源代码中存在,在编译后的字节码文件中,全部泛型被替换为原来的裸类型,并在使用泛型的地方进行强制类型转换.

**泛型的产生**

在JDK1.5中加入泛型的时候,为了兼容旧的Class文件在引入泛型之后可以继续工作.大概有两条方案

* 新增一套泛型化版本的API(主要针对容器类型).C#方案
* 把已有类型泛型化. Java方案.

如果按照把已有类型泛型化的方案实现.仍然有两个选择.

* 在运行期间由虚拟机自动真实的构造出ArrayList<Integer> 这样的类型,并且自动实现ArrayList<Integer>  派生自ArrayList 的继承关系来满足安全转型需要.

* 简单粗暴将ArrayList<Integer>还原为ArrayList,在元素访问,修改时自动插入强制类型转换和指令检查.

**特点**:

1. 实现简单,只需要修改Javac编译器.
2. 不支持原生类型泛型.
3. 运行期间无法获得泛型信息.不能new T,T表示泛型
4. 丧失面向对象思想应有的优雅,泛型不能构成重载,但是返回值不一样又实在的构成重载(与我们知道返回值不参数重载违背)

##### 1.1.2 自动装箱,拆箱与循环遍历

举例说明自动装箱拆箱与循环遍历前后代码变化.

源代码:

```
public static void main(String[] args) {
     List<Integer> list = Arrays.asList(1, 2, 3, 4);
     int sum = 0;
     for (int i : list) {
     sum += i;
     }
     System.out.println(sum);
 }
```

Javac进行编译编译后等如下所示代码同于

```
public static void main(String[] args) {
     List list = Arrays.asList(new Integer[]{
     Integer.valueOf(1),
     Integer.valueOf(2),
     Integer.valueOf(3), Integer.valueOf(4)});
     int sum = 0;
     for (Iterator localIterator = list.iterator();localIterator.hasNext(); ) {
         int i = ((Integer) localIterator.next()).intValue();
         sum += i;
     }
     System.out.println(sum);
 }
```

可以看到自动装箱怎么实现的,泛型被擦除了,foreach循环等同Iterable遍历

##### 1.1.3 条件编译

Java在编译过程中Javac编译器会自动把分支中无法执行的代码块消除掉.

### 2 实战:插入式注解处理器

这部分将时候注解处理器API编写一款自己爹编码风格校验工具:`NameCheckProcessor` 

#### 代码实现

todo

### 后端编译与优化

**解释器和编译器**

当程序启动后,解释起可以首先发挥作用,省去编译时间.当程序启动后,随着时间推移,编译器逐渐返回作用,把越来越多的代码编译称为本地代码.

**即时编译器热点代码**
包括被多次调用的方法,被多次执行的循环体.

如何确实是不是热点代码?

1. 栈顶采样
2. 计数器计算.

**提前编译器**

提前编译的两条选择:

1. 向C/C++一样把程序代码编译成为机器码.缺点:编译占用时间.
2. 给即时编译器做缓存加速.Java这是Java主流技术体系方案.

即时编译存在占用占用程序运行时间的问题.

#### 编译器优化技术

接下来，笔者挑选了四项有代表性的优化技术，与大家一起观察它们是如何运作 的。它们分别是：

* 最重要的优化技术之一：方法内联。 
* 最前沿的优化技术之一：逃逸分析。 
* 语言无关的经典优化技术之一：公共子表达式消除。 
* 语言相关的经典优化技术之一：数组边界检查消除。

##### 方法内联

内联就是把目标方法代码移动到发起调用的方法,节约方法调用开销.

**困难** :只有调用非虚方法才能在编译期间解析.糟糕的是,Java对象默认方法都是虚方法.

##### 逃逸分析

**原理**: 分析对象动态作用域,当一个对象在放里面被定义后,有三种逃逸程度,不逃逸,方法逃逸,线程逃逸.

优化:

1. 栈上分配内存:对象直接在栈上分配内存,支持方法逃逸
2. 标量替换:如果对象不允许逃逸,则可以用原始类型数据替换对象
3. 同步消除:如果证明一个变量不对线程逃逸,则可以把对这个变量实施的同步措施取消

##### 公共子表达式消除

如下代码:

```
int d = (c * b) * 12 + a + (a + b * c);
```

在即使编译后会变成:

```
int d = E * 12 + a + (a + E);
```

##### 数组边界检查消除

在Java语言中访问数组元组系统会自动进行上下边界范围检查,不符合则抛出`java.lang.ArayIndexOutOfBoundsException` 异常.

优化:比如在循环中,只要判断循环变量在数组length之间,则省略掉边界检查.





