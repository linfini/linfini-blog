# Java内存区域

## 运行时数据区域

![img](https://pic2.zhimg.com/80/v2-a1cf6bf507d167385752aa635d9134e5_720w.webp)



###  1程序计数器

记录字节码指令，不会OOM

### 2虚拟机栈

使用最多的局部变量存放表，基本类型和对象引用

### 3本地方法栈

为本地方法服务的栈。

### 4 Java堆

堆是虚拟机管理中内存最大的区域，线程共享。所有对象实例以及数组都应该在堆上分配。 

### 方法区

存储被虚拟机加载的类型信息，常量，静态变量，即时编译器代码缓存等。

#### 运行时常量池

存放编译期间生成的各种字面量与符号引用。

字面量：即用双引号创建的字符串常量，final变量

## 虚拟机对象

### 1.对象的创建

* 1类加载检查

  当遇到new指令之后，首先会去到**静态常量池**中看看能否找到这个指令所对应的**符号引用**，然后会检查**符号引用**所对应的**类**是否被**加载——连接——初始化**，如果有的话就进行第二步，如果没有就要先进行类的加载。

*  2执行类加载

* 3为新生对象分配内存

  假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
   总结：

  - 堆状态：规整
  - 对应的垃圾回收器：Serial、ParNew
  - 对应的垃圾回收算法：复制算法

  **空闲列表**

  如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。
   总结：

  - 堆状态：不规整
  - 对应的垃圾回收器：CMS
  - 对应的垃圾回收算法：标记清除

  **并发问题**

  在并发情况下划分不一定是线程安全的，有可能出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针分配内存的情况，所以解决方法：

  - CAS+失败重试：通过CAS乐观锁去尝试更新此次操作，如果CAS失败就去重试，直至成功为止。
  - TLAB：预先在堆内存的Eden区为每一个线程分配一块名为TLAB的预存地址空间，当创建对象的时候就可以使用这块内存，当TLAB空间被占满时，再去采用CAS+失败重试的方法区分配内存。

* 4.设置初始值和对象头
  **虚拟机需要将分配到的内存空间中的数据类型都初始化为零值（不包括对象头）**，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值

  初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

* 5.执行构造函数，即class文件中<init>（）方法

### 2.对象的内存布局



