这部分介绍内存管理和垃圾回收

### Java内存区域与内存溢出异常

Java虚拟机的自动内存管理机制帮助我们自动分配和销毁内存.

#### 运行时数据区域

![img](https://pic2.zhimg.com/80/v2-a1cf6bf507d167385752aa635d9134e5_720w.webp)



1. **程序计数器**: 可以看做字节码指令流的行号指示器,通过改变计数器的值来选取下一条指令.程序分支,循环跳转,异常处理都需要依赖程序计数器.程序计数器不会发生内存溢出`OutOfMemoryError`

2. **虚拟机栈:** 虚拟机栈描述Java方法执行的内存模型,每个方法执行的时候,虚拟机都会同步创建一个栈帧,用于局部变量,操作数栈,动态链接等信息.

   **StackOverflow **: 当栈帧大于-Xss设置的值,就会引发该异常,常见于死循环.

3. 本地方法栈:为native方法服务,同虚拟机栈.hotspot中,本地方法栈和虚拟机栈合二为一.

4. **Java堆:** 对象实例在堆上分配,Java在逻辑上认为内存空间连续,大对象则要求实际的连续空间.通过-Xmx -Xms参数设定堆大小.

5. **方法区:** Jdk8之前交永久代,Jdk8中使用元空间实现.这部分内存回收主要针对常量池回收.

   **运行时常量池**: 在类加载后把Class文件中的常量表 存放在运行时常量池.但是进入常量池不一定在解析阶段,有可能在运行阶段.参考类加载解析和动态分派的概念.

#### HotSpot中对象

HotSpot中对象分配,布局,和访问

**对象的创建**:

1. 当遇到new指令之后，首先会去到**静态常量池**中看看能否找到这个指令所对应的**符号引用**，然后会检查**符号引用**所对应的**类**是否被**加载——连接——初始化**，如果有的话就进行下一步，如果没有就要先进行类的加载。

2. 执行类加载

3. 为新生对象分配内存

   分配策略:

   * 指针碰撞:当有足够大内存空间时,将指针移动向空闲空间防线.并发分配内存的问题,采用CAS失败重试机制或采用本地线程缓冲区分配.
   * 空闲列表:内存碎片化严重时,就只能采用表记录可用的内存空间.

4. 设置初始值和对象头
   **虚拟机需要将分配到的内存空间中的数据类型都初始化为零值（不包括对象头）**，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值

   初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. 执行构造函数，即class文件中<init>（）方法

**对象的内存布局**

对象在对内存布局：对象头，实例数据，和对齐填充。

* **对象头**

1. 线程运行时数据，哈希码，GC分代年龄，锁状态标识，线程持有锁，偏向线程ID等。
2. Java类型指针，指向方法区元数据的指针,Java虚拟机用这个指针确实该对象是哪个类的实例

* **实例数据** :即对象字段内容.

**对象访问方式**

是由虚拟机实现的,主流有句柄和直接指针两种:

1. **句柄访问,**句柄中包含了对象实例数据与类型数据各自具体的地址信息.reference中可以存储稳定的句柄地址.
2. **直接指针访问**,引用reference中存储的直接就是对象地址,指向实例数据.访问速度快.

![img](https://img-blog.csdn.net/20180829135125817?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDA1OTQz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![img](https://img-blog.csdn.net/20150710172441054?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

------

### 垃圾收集器和内存分配策略

程序计数器,虚拟机栈,本地方法栈3块内存区域,是线程私有,线程结束时,内存自动回收.堆和方法区的内存分配和销毁是动态,以下介绍管理收集器如何管理这部分内存.

#### 判断对象死亡

1. 引用计数法:对象被引用时,计数器+1,当引用失效时计数器-1.当计数器为0时,对象不能再被使用.这个算法比较经典,但是比较难以解决循环引用的问题,需要额外空间存储和频繁更新.

2. 可达性分析算法:主流虚拟机采用的算法.如果某个对象到GC Roots对象间没有任何引用链相连,则对象不能被使用.

   GC Roots是一组必须活跃的引用,可以是栈中引用,静态引用对象.常量池引用,`syschronized` 锁持有对象等.

**引用类型**

1. **强引用**:只要强引用关系还在,垃圾收集器永远不会回收被引用的对象.使用new创建的引用关系.

2. **软引用**:用`java.lang.ref.SoftReference`实现，可以让对象豁免一些垃圾收集。当系统内存充足的时候，不会被回收；当系统内存不足的时候，会被回收。

   使用场景:一个应用需要读取大量的本地图片，如果每次读取都从硬盘读取会严重影响性能，如果一次性全部加载到内存，内存可能会溢出。

3. **弱引用**:弱引用需要用`java.lang.ref.WeakReference`实现，它比软引用的生存期更短，对于弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否够，都会回收该对象的占用内存。

4. **虚引用**:虚引用要通过` java.lang.ref.PhantomReference`类来实现，虚引用不会决定对象的生命周期，如果一个对象只有虚引用，就相当于没有引用，在任何时候都可能会被垃圾回收器回收。它不能单独使用也不能访问对象，虚引用必须和引用队列联合使用。

#### 垃圾回收算法

垃圾收集建立在分代假说之上:绝大多数对象都快速消亡;熬过越多次垃圾收集的对象就越难消亡.根据对象年龄划分出不同的区域.年纪小的经常回收,年纪大的不怎么回收.基于这个理论,一般有新生代,老年代的划分.

**跨代引用假说**:跨代引用占少数.

在回收新生代对象的时候,需要在GC Roots之外,额外遍历老年代对象保证可达性分析准确.所以采用在老年代中标志出存在跨代引用的对象加入GC Roots,从而避免扫描整个老年代.

**标记-清除算法**:标记需要回收的对象,标记完成后统一回收被标记的对象.

缺点:

1. 执行效率随着对象数量增长而降低
2. 标记-清除完成之后会导致没有足够连续的空间

**标记-复制算法**:将可用内存划分为两块,当一块内容使用完了,就存活的对象复制到另一块,并将已经使用的内存空间清理掉.为了解决标记-清除算法效率低的问题.大部分虚拟机在新生代采用这种算法.

一般新生代划分为Eden和Surviror两块空间,Hotspot中默认比例是8:1.

**标记-整理算法**:在老年代采取的算法,因为老年代对象存活率较高,不适合标记-复制算法.在标记完成对象之后,对存活对象进行进行移动.

缺点:由于要移动程序需要停顿

由于标记-整理算法和标记-清除算法都存在缺点.产生了一种混合式的回收策略,大部分时间都用标记--清除算法回收,当内存碎片化过于严重时,采用标记-整理收集获取规整的内存空间.

#### HotSpot算法细节实现



------

## 虚拟机对象



​                                          

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

