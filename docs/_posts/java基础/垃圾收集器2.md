# 垃圾收集器

### 如何判断对象已死

如何判断对象"存活"着,哪些已经"死去"?

**引用计数器法**

有引用时,计数器加一.引用失效时,计数器减一.

缺点:无法解决循环引用的问题

**可达性分析算法**

如果某个对象到GC Roots间没有任何引用链相连,则证明此对象不能再被使用.

**引用类型**

**强引用**:只要强引用关系还在,垃圾收集器永远不会回收被引用的对象.使用new创建的引用关系.

**软引用**:用`java.lang.ref.SoftReference`实现，可以让对象豁免一些垃圾收集。当系统内存充足的时候，不会被回收；当系统内存不足的时候，会被回收。

使用场景:一个应用需要读取大量的本地图片，如果每次读取都从硬盘读取会严重影响性能，如果一次性全部加载到内存，内存可能会溢出。

**弱引用**:弱引用需要用`java.lang.ref.WeakReference`实现，它比软引用的生存期更短，对于弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否够，都会回收该对象的占用内存。

**虚引用**:虚引用要通过` java.lang.ref.PhantomReference`类来实现，虚引用不会决定对象的生命周期，如果一个对象只有虚引用，就相当于没有引用，在任何时候都可能会被垃圾回收器回收。它不能单独使用也不能访问对象，虚引用必须和引用队列联合使用。

### 垃圾收集算法

对象收集建立在分代假说之上:绝大多数对象都快速消亡;熬过越多次垃圾收集的对象就越难消亡.

**标记-清除算法**:标记需要回收的对象,标记完成后统一回收被标记的对象.缺点:1)执行效率随着对象数量增长而降低2)标记-清除完成之后会导致没有足够连续的空间

**标记-复制算法**:将可用内存划分为两块,当一块内容使用完了,就存活的对象复制到另一块,并将已经使用的内存空间清理掉.为了解决标记-清除算法效率低的问题.一般在新生代中使用.

一般新生代划分为Eden和Surviror两块空间,Hotspot中默认比例是8:1.

**标记-整理算法**:在标记完成对象之后,对存活对象进行进行移动.

### 内存分配与回收策略

1)对象优先在Eden分配,当Eden区域没有足够的空间时候,虚拟机发起Minor GC

2)大对象直接进入老年代,hotspot虚拟机提供参数置顶对象大小阈值,-XX：PretenureSizeThreshold.避免对象在Eden和Survivor之间来回复制.

3)长期存活的对象进入老年代.年龄大于一定阈值的对象可以进入老年代,在Survivor中没熬过一个Minor GC对象年龄增加一岁.

4)空间分配担保:当大量对象在Minor GC后仍然存活,需要老年代进行分配担保.为了判断老年代是否还有空间容纳这些对象的空间,去之前每次晋升到老年代对量平均大小作为参考值.不允许担保,则直接进行Full GC













